# -*- coding: utf-8 -*-
"""diff_approx_num_methods.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19CN2bfqmVqpmEvSTT7FYUyX-ZnewPVGG
"""

def runge_kutta(fxy, x0, y0,xn,h = 0):
  n = int((xn - x0)/h)
  for j in range(n):
    x,y,k0,Y= (x0,y0,0,0)
    for i in range(1,5):
      d = int(max(min(2,i%4),1))
      x,y = (x0+max(0,min(1,i-1))*h/d,y0+k0/d)
      k = h*eval(fxy)
      print('k'+str(i)+' = ',k)
      k0 = k
      Y+=d*k/6
    print('y(',x0+h,')= ',y0+Y)
    y0 = Y+y0
    x0 +=h
  return y0

def eulers_modified(fxy, x0, y0,xn,h = 0):
  n = int((xn-x0)/h)
  for i in range(n):
    x,y = (x0,y0)
    m0 = float(eval(fxy))
    x+=h
    for i in range(4):
      y = y0 + (h/2)*(m0 + eval(fxy))
      print('y = ',y)
    print('y(',x0+h,') = ',y)
    x0,y0 = x,y

def inputs():
  fxy = input('Enter dy/dx in terms of x,y')
  x0,y0 = map(int,input('Enter x0,y0 (format: x0,y0 )').split(','))
  xn = float(input('Enter value of x at which you want to evaluate y (xn)'))
  y = input('Entering h?(y/n)')
  if y=='y':
    h = float(input())
  else: 
    h = xn - x0
  return fxy,x0,y0,xn,h

def main():
  fxy,x0,y0,xn,h = inputs()
  print("Prediction using Euler's Modified Method")
  eulers_modified(fxy,x0,y0,xn,h)
  print("Prediction using Runge Kutta Method")
  runge_kutta(fxy,x0,y0,xn,h)

main()

runge_kutta('x+y',0,1,0.2,0.1)